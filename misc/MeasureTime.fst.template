module MeasureTime

module F   = Experiment.Steel.Monad
module T   = FStar.Tactics
module M   = Experiment.Steel.Repr.M
module C   = Experiment.Steel.Combinators
module SH  = Experiment.Steel.Steel
module U32 = FStar.UInt32

open Steel.Effect
open Steel.Reference
open Learn.Tactics.Util


inline_for_extraction
let steel_add_1 (r : ref U32.t)
  : Steel unit (vptr r) (fun () -> vptr r)
      (requires fun h0       -> U32.v (sel r h0) < FStar.UInt.max_int U32.n)
      (ensures  fun h0 () h1 -> U32.v (sel r h1) = U32.v (sel r h0) + 1)
  =
    let x = read r in
    write r U32.(x +^ 1ul)

noextract
let rec repeat_n (n : nat) (t : M.repr SH.KSteel unit) : M.repr SH.KSteel unit
  = F.(if n = 0 then C.return SH.KSteel () else (C.bind t (fun _ -> repeat_n (n-1) t)))

#push-options "--query_stats"
noextract inline_for_extraction
let test_time (r : ref U32.t)
  : F.steel unit (vptr r) (fun () -> vptr r)
      (requires fun h0       -> U32.v (sel r h0) <= 100)
      (ensures  fun h0 () h1 -> U32.v (sel r h1) = U32.v (sel r h0) + REPEAT)
  = F.(to_steel (repeat_n REPEAT (call steel_add_1 r))
        #(_ by T.(
          norm [delta_only [`%repeat_n]; iota; zeta; primops];
          print ("begin test n :REPEAT");
	  print ("begin at : "^string_of_int (curms ()));
          mk_steel [Timer; Extract]))
         ())
#pop-options

noextract
let _ : unit = _ by T.(
          print ("end at : "^string_of_int (curms ()));
          exact (`()))

let test_extract (r : ref U32.t)
  : Steel unit (vptr r) (fun () -> vptr r)
      (requires fun h0       -> U32.v (sel r h0) <= 100)
      (ensures  fun h0 () h1 -> U32.v (sel r h1) = U32.v (sel r h0) + REPEAT)
  = test_time r ()
